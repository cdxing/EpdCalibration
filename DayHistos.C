/*
The purpose of this code is to create graphs
based off of the text files generated by EPD
calibration (EW PP TT ADC format) and to then
line fit those graphs to an average value (day
vs ADC per tile). It then will plot the
chi2/ndf of each fit line to see if there are
any trends of drift from an average value over
the days.

-Skipper Kagamaster
*/

/// C++ Headers
#include <iostream>
#include <fstream>

/// ROOT Headers
#include "TFile.h"
#include "TChain.h"
#include "TSystem.h"
#include "TH1.h"
#include "TMath.h"
#include "TTree.h"

void DayHistos(int dayStart = 1, int dayEnd = 27, const Char_t *inFile = "NmipConstantsDays1_27.txt")
{

/// This is what I'll want to do for saving; I need to define day.
//Form("NmipsDay%d",day);

/// Let's make stuff to hold the data.
Double_t tAve[2][12][31];
Double_t tAveErr[2][12][31];
Double_t tChi2[2][12][31];
Int_t day, ew, pp, tt, days, total;
Double_t adc, err, ey;
int runStart = 41;
int runEnd = 55;
//int dayStart = 344;
//int dayEnd = 365;
days = runEnd-runStart+1;
int runTotal = 4464*(days);//only East side
double data[runTotal];
Double_t nMipADC[days][2][12][31];
Double_t nMipError[days][2][12][31];
//std::ofstream NmipFile(Form("/mnt/c/Users/pjska/github/EpdCalibration/Nmip_Day_%d.txt",dayStart),ofstream::out);
//double data[4464];

/// This bit of code is to read the text file and give ROOT some usable data.
    std::ifstream input(inFile);

    for (int i = 0; i < runTotal; i+=1)
    //for (int i = 0; i < 4464; i+=1)
    {
        input >> data[i];
    }

/// And now we'll fill our array with the data (arranged by ew, pp, tt).
    for (int i = 0; i < runTotal; i+=6)
    {
      // if (data[i] < 109)
      // {
      //   day = (int) data[i];
      // }
      // else if ((data[i]>109)&&(data[i]<116))
      // {
      //   day = (int) data[i]-1;
      // }
      // else if (data[i] > 116)
      // {
      //   day = (int) data[i]-2;
      // }
      day = (int) data[i];

      ew = (int) data[i+1];
      pp = (int) data[i+2];
      tt = (int) data[i+3];
      adc = data[i+4];
      err = data[i+5];
      ey = 0;
      // if((day == 172)||(day == 173))
      // {
      //   std::cout << "adc = " << adc << std::endl;
      // }
      nMipADC[day-runStart][ew][pp-1][tt-1] = adc;
      nMipError[day-runStart][ew][pp-1][tt-1] = err;
    }

/// Loop for the tile graphs.
    TCanvas *c1 = new TCanvas("c1","Day vs 1st nMip",490,175,1332,799);
    /// Use this to divide the canvas.
   	//c1->Divide(4,8,0,0);
    TGraphErrors* gr[31]; //= new TGraphErrors();
    c1->SaveAs(Form("/mnt/c/Users/pjska/service/2020_11p5GeV/EpdCalibration/result/ChiFitTT_%d_%d.pdf[",dayStart,dayEnd));
    //c1->SaveAs("/mnt/c/Users/pjska/github/EpdCalibration/result_R20_7p7_FXT/ChiFitTT.pdf[");
    for (int i = 0; i < 2; ++i) // East side only for FXT
    {
      ew = i;
      for (int j = 0; j < 12; ++j)
   	  {
   	  	pp = j+1;
        for (int k = 0; k < 31; ++k)
   	  	{
   	  		tt = k+1;
          gr[k] = new TGraphErrors();
   	  		for (int day = dayStart; day < dayEnd+1; ++day)
          {
            int d;
            // if (day<109)
            // {
               d=day-runStart;
            // }
            // else if (day==109)
            // {
            //   continue;
            // }
            // else if ((day>109)&&(day<116))
            // {
            //   d=day-runStart-1;
            // }
            // else if (day==116)
            // {
            //   continue;
            // }
            // else if (day>116)
            // {
            //   d=day-runStart-2;
            // }
            gr[k]->SetPoint(d,day,nMipADC[d][i][j][k]);
            gr[k]->SetPointError(d,0,nMipError[d][i][j][k]);
   	  		}

          /// Just some graphing nonsense.
          gr[k]->GetXaxis()->SetTitle("Run serial number");
          gr[k]->GetXaxis()->CenterTitle(true);
          gr[k]->GetXaxis()->SetNdivisions(310);
          gr[k]->GetXaxis()->SetLabelFont(42);
          gr[k]->GetXaxis()->SetLabelOffset(0.013);
          gr[k]->GetXaxis()->SetTitleSize(0.05);
          gr[k]->GetXaxis()->SetTitleOffset(0.93);
          gr[k]->GetXaxis()->SetTitleFont(42);
          gr[k]->GetYaxis()->SetTitle("ADC");
          gr[k]->GetYaxis()->SetNdivisions(506);
          gr[k]->GetYaxis()->SetLabelFont(42);
          gr[k]->GetYaxis()->SetLabelSize(0.05);
          gr[k]->GetYaxis()->SetTitleSize(0.05);
          gr[k]->GetYaxis()->SetTitleOffset(0.96);
          gr[k]->GetYaxis()->SetTitleFont(42);
          gr[k]->SetMarkerStyle(6);
 	   			gr[k]->Draw("AP");
 	   			gr[k]->Fit("pol0","q");
          TFitResultPtr r = gr[k]->Fit("pol0","Sq");
          TMatrixDSym cov = r->GetCovarianceMatrix();
          tChi2[i][j][k] = r->Chi2()/r->Ndf();
          Double_t Ave  = r->Value(0);
          Double_t aErr = r->ParError(0);
          //NmipFile << Form("%d \t%d \t%d \t%d \t%lf",dayStart,ew,pp,tt,Ave);
          //NmipFile << endl;
          tAve[i][j][k] = Ave;
          tAveErr[i][j][k] = aErr;
          std::string ave = std::to_string(Ave);
          gr[k]->SetTitle(ave.c_str());
          TPaveText *pt = new TPaveText(0.4752221,0.7149081,0.8750854,0.891545,"brNDC");
          gr[k]->SetMinimum(Ave-15);
          gr[k]->SetMaximum(Ave+35);
          pt->SetBorderSize(0);
          pt->SetFillColor(0);
          TText *pt_LaTex = pt->AddText(Form("EW%i_PP%i_TT%i",ew,pp,tt));
          pt->Draw();
          c1->SaveAs(Form("/mnt/c/Users/pjska/service/2020_11p5GeV/EpdCalibration/result/ChiFitTT_%d_%d.pdf",dayStart,dayEnd));
          //c1->SaveAs("/mnt/c/Users/pjska/github/EpdCalibration/result_R20_7p7_FXT/ChiFitTT.pdf");
 	   	  }
      }
    }
  c1->SaveAs(Form("/mnt/c/Users/pjska/service/2020_11p5GeV/EpdCalibration/result/ChiFitTT_%d_%d.pdf]",dayStart,dayEnd));
  //c1->SaveAs("/mnt/c/Users/pjska/github/EpdCalibration/result_R20_7p7_FXT/ChiFitTT.pdf]");

    /// Now to plot the chi2/ndf for each tile.
    TCanvas *c2 = new TCanvas("c2","Average per Tile",490,175,1332,799);
    TGraphErrors* sg;
    sg = new TGraphErrors();
    Double_t cAve[31];
    Double_t cAveErr[31];
    c1->SaveAs(Form("/mnt/c/Users/pjska/service/2020_11p5GeV/EpdCalibration/result/ChiFitSS_%d_%d.pdf[",dayStart,dayEnd));
    //c2->SaveAs("/mnt/c/Users/pjska/github/EpdCalibration/result_R20_7p7_FXT/ChiFitSS.pdf[");
    for (int i = 0; i < 2; ++i) // only East side
    {
        ew = i;
        for (int j = 0; j < 12; ++j)
        {
          pp = j+1;
          Int_t l = 0;
          for (int k = 0; k < 31; ++k)
          {
            tt = k+1;
            cAve[l] = tChi2[i][j][k];
            sg->SetPoint(l,l+1,cAve[l]);
            sg->SetMarkerColor(kRed);
            l++;
            }
          sg->GetXaxis()->SetTitle("Tile #");
          sg->GetYaxis()->SetTitle("#chi^{2}/Ndf");
          sg->GetXaxis()->SetNdivisions(232);
          sg->GetYaxis()->SetNdivisions(410);
          sg->SetMarkerStyle(7);
          sg->Draw("APL");
          TPaveText *st = new TPaveText(0.4752221,0.7149081,0.8750854,0.891545,"brNDC");
          st->SetBorderSize(0);
          st->SetFillColor(0);
          TText *st_LaTex = st->AddText(Form("EW%i_PP%i",ew,pp));
          st->Draw();
          //c2->SaveAs("/mnt/c/Users/pjska/github/EpdCalibration/result_R20_7p7_FXT/ChiFitSS.pdf");
          c2->SaveAs(Form("/mnt/c/Users/pjska/service/2020_11p5GeV/EpdCalibration/result/ChiFitSS_%d_%d.pdf",dayStart,dayEnd));
        }
    }
  //c2->SaveAs("/mnt/c/Users/pjska/github/EpdCalibration/result_R20_7p7_FXT/ChiFitSS.pdf]");
  c2->SaveAs(Form("/mnt/c/Users/pjska/service/2020_11p5GeV/EpdCalibration/result/ChiFitSS_%d_%d.pdf]",dayStart,dayEnd));
}
